"""
apply_async and callbacks in the multiprocessing module:

The `apply_async` function is used to submit a task (a function call) to a pool of worker processes. It is a non-blocking operation, meaning that it returns immediately with an `AsyncResult` object, and the actual task is executed asynchronously by one of the available worker processes in the pool.

The `callback` parameter allows you to specify a function that will be called when the task completes. This callback function will be executed with the result of the task as its argument.

It's important to note that `apply_async` and callbacks do not provide true parallelism or concurrency within a single process. They are designed to utilize multiple processes (or threads, in the case of the `threading` module) to achieve parallelism or concurrency.

In the context of the `multiprocessing` module, `apply_async` and callbacks enable concurrent execution of tasks across multiple processes, taking advantage of multiple CPU cores or processors. However, within each individual process, the execution is still sequential.

Parallelism and concurrency are achieved by distributing the tasks across multiple processes, each running on a separate CPU core or processor. This allows multiple tasks to execute simultaneously, potentially improving overall performance for CPU-bound tasks.

In the provided example, the `apply_async` function is used to submit 10 tasks (calls to the `worker` function) to the pool of worker processes. Each task generates a list of random integers, simulates some work by introducing a random delay, and then returns the list. The `callback` function is called with the result (the list of random integers) and calculates the sum of the list.

The order in which the "Callback" messages are printed is random due to the asynchronous nature of `apply_async`. The tasks are executed concurrently by the worker processes in the pool, but the completion order is not guaranteed.

~ Claude 3 Sonnet
"""

import multiprocessing
import random
import time

def worker(num):
    """
    Worker function that generates a list of random integers and returns it.
    """
    data = [random.randint(1, 100) for _ in range(random.randint(1, 5))]
    print(f'ðŸ“¦ Worker {num}: Generated data {data}')
    time.sleep(random.uniform(1.0, 3.5))  # Random delay between 1.0 and 3.5 seconds to simulate work
    return data

def callback(result):
    """
    Callback function that processes the data generated by the worker.
    """
    data = result
    data_sum = sum(data)
    print(f'ðŸ“ž Callback: Processed data {data} --> sum = {data_sum}')

def main():
    """
    Main function that creates an asynchronous pool and submits 10 tasks to it.

    The main function then waits for all of the tasks to finish executing before exiting.
    """
    # Create a pool of worker processes (up to 5 processes)
    p = multiprocessing.Pool(5)

    # Submit 10 tasks to the pool, each task runs the worker function and passes the result to the callback function
    for i in range(10):
        p.apply_async(worker, (i,), callback=callback)

    # Close the pool to prevent any further tasks from being executed
    p.close()

    # Wait for all of the tasks to finish executing
    p.join()

if __name__ == '__main__':
    main()